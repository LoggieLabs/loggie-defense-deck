import{A as de,B as he,C as pe,a as se,b as Mt,c as E,e as Ut,f as ce,h as ie,i as Ct,m as vt,n as St,o as fe,p as le,q as Rt,s as ue,z as ae}from"./chunk-75GD3YN4.js";import{d as $}from"./chunk-SU2Z73VX.js";function ge(t,e=""){if(typeof t!="boolean"){let n=e&&`"${e}" `;throw new Error(n+"expected boolean, got type="+typeof t)}return t}var He=BigInt(0),ht=BigInt(1),Ne=BigInt(2),je=BigInt(7),Fe=BigInt(256),Ge=BigInt(113),we=[],me=[],be=[];for(let t=0,e=ht,n=1,o=0;t<24;t++){[n,o]=[o,(2*n+3*o)%5],we.push(2*(5*o+n)),me.push((t+1)*(t+2)/2%64);let r=He;for(let u=0;u<7;u++)e=(e<<ht^(e>>je)*Ge)%Fe,e&Ne&&(r^=ht<<(ht<<BigInt(u))-ht);be.push(r)}var Ee=ue(be,!0),Ke=Ee[0],$e=Ee[1],ye=(t,e,n)=>n>32?he(t,e,n):ae(t,e,n),xe=(t,e,n)=>n>32?pe(t,e,n):de(t,e,n);function Ye(t,e=24){let n=new Uint32Array(10);for(let o=24-e;o<24;o++){for(let c=0;c<10;c++)n[c]=t[c]^t[c+10]^t[c+20]^t[c+30]^t[c+40];for(let c=0;c<10;c+=2){let d=(c+8)%10,x=(c+2)%10,A=n[x],g=n[x+1],S=ye(A,g,1)^n[d],W=xe(A,g,1)^n[d+1];for(let R=0;R<50;R+=10)t[c+R]^=S,t[c+R+1]^=W}let r=t[2],u=t[3];for(let c=0;c<24;c++){let d=me[c],x=ye(r,u,d),A=xe(r,u,d),g=we[c];r=t[g],u=t[g+1],t[g]=x,t[g+1]=A}for(let c=0;c<50;c+=10){for(let d=0;d<10;d++)n[d]=t[c+d];for(let d=0;d<10;d++)t[c+d]^=~n[(d+2)%10]&n[(d+4)%10]}t[0]^=Ke[o],t[1]^=$e[o]}Ct(n)}var Pt=class t{constructor(e,n,o,r=!1,u=24){$(this,"state");$(this,"pos",0);$(this,"posOut",0);$(this,"finished",!1);$(this,"state32");$(this,"destroyed",!1);$(this,"blockLen");$(this,"suffix");$(this,"outputLen");$(this,"enableXOF",!1);$(this,"rounds");if(this.blockLen=e,this.suffix=n,this.outputLen=o,this.enableXOF=r,this.rounds=u,Mt(o,"outputLen"),!(0<e&&e<200))throw new Error("only keccak-f1600 function is supported");this.state=new Uint8Array(200),this.state32=ie(this.state)}clone(){return this._cloneInto()}keccak(){vt(this.state32),Ye(this.state32,this.rounds),vt(this.state32),this.posOut=0,this.pos=0}update(e){Ut(this),E(e);let{blockLen:n,state:o}=this,r=e.length;for(let u=0;u<r;){let c=Math.min(n-this.pos,r-u);for(let d=0;d<c;d++)o[this.pos++]^=e[u++];this.pos===n&&this.keccak()}return this}finish(){if(this.finished)return;this.finished=!0;let{state:e,suffix:n,pos:o,blockLen:r}=this;e[o]^=n,(n&128)!==0&&o===r-1&&this.keccak(),e[r-1]^=128,this.keccak()}writeInto(e){Ut(this,!1),E(e),this.finish();let n=this.state,{blockLen:o}=this;for(let r=0,u=e.length;r<u;){this.posOut>=o&&this.keccak();let c=Math.min(o-this.posOut,u-r);e.set(n.subarray(this.posOut,this.posOut+c),r),this.posOut+=c,r+=c}return e}xofInto(e){if(!this.enableXOF)throw new Error("XOF is not possible for this instance");return this.writeInto(e)}xof(e){return Mt(e),this.xofInto(new Uint8Array(e))}digestInto(e){if(ce(e,this),this.finished)throw new Error("digest() was already called");return this.writeInto(e),this.destroy(),e}digest(){return this.digestInto(new Uint8Array(this.outputLen))}destroy(){this.destroyed=!0,Ct(this.state)}_cloneInto(e){let{blockLen:n,suffix:o,outputLen:r,rounds:u,enableXOF:c}=this;return e||(e=new t(n,o,r,c,u)),e.state32.set(this.state32),e.pos=this.pos,e.posOut=this.posOut,e.finished=this.finished,e.rounds=u,e.suffix=o,e.outputLen=r,e.enableXOF=c,e.destroyed=this.destroyed,e}};var Ae=(t,e,n,o={})=>fe((r={})=>new Pt(e,t,r.dkLen===void 0?n:r.dkLen,!0),o),Be=Ae(31,168,16,Rt(11)),H=Ae(31,136,32,Rt(12));function Ht(t){if(!Number.isSafeInteger(t)||t<0||t>4294967295)throw new Error("wrong u32 integer:"+t);return t}function ke(t){return Ht(t),(t&t-1)===0&&t!==0}function Nt(t,e){Ht(t);let n=0;for(let o=0;o<e;o++,t>>>=1)n=n<<1|t&1;return n}function Oe(t){return Ht(t),31-Math.clz32(t)}function Te(t){let e=t.length;if(e<2||!ke(e))throw new Error("n must be a power of 2 and greater than 1. Got "+e);let n=Oe(e);for(let o=0;o<e;o++){let r=Nt(o,n);if(o<r){let u=t[o];t[o]=t[r],t[r]=u}}return t}var jt=(t,e)=>{let{N:n,roots:o,dit:r,invertButterflies:u=!1,skipStages:c=0,brp:d=!0}=e,x=Oe(n);if(!ke(n))throw new Error("FFT: Polynomial size should be power of two");let A=r!==u;return g=>{if(g.length!==n)throw new Error("FFT: wrong Polynomial length");r&&d&&Te(g);for(let S=0,W=1;S<x-c;S++){let R=r?S+1+c:x-S,V=1<<R,tt=V>>1,xt=n>>R;for(let st=0;st<n;st+=V)for(let p=0,w=W++;p<tt;p++){let I=u?r?n-w:w:p*xt,Y=st+p,N=st+p+tt,X=o[I],C=g[N],B=g[Y];if(A){let v=t.mul(C,X);g[Y]=t.add(B,v),g[N]=t.sub(B,v)}else u?(g[Y]=t.add(C,B),g[N]=t.mul(t.sub(C,B),X)):(g[Y]=t.add(B,C),g[N]=t.mul(t.sub(B,C),X))}}return!r&&d&&Te(g),g}};var Ft=le;function Gt(t,e){if(t.length!==e.length)return!1;let n=0;for(let o=0;o<t.length;o++)n|=t[o]^e[o];return n===0}function Kt(t){if(typeof t!="object"||t===null||se(t))throw new Error("expected opts to be an object")}function Bt(t){Kt(t),t.context!==void 0&&E(t.context,void 0,"opts.context")}function Tt(t){Bt(t),t.extraEntropy!==!1&&t.extraEntropy!==void 0&&E(t.extraEntropy,void 0,"opts.extraEntropy")}function pt(t,...e){let n=r=>typeof r=="number"?r:r.bytesLen,o=e.reduce((r,u)=>r+n(u),0);return{bytesLen:o,encode:r=>{let u=new Uint8Array(o);for(let c=0,d=0;c<e.length;c++){let x=e[c],A=n(x),g=typeof x=="number"?r[c]:x.encode(r[c]);E(g,A,t),u.set(g,d),typeof x!="number"&&g.fill(0),d+=A}return u},decode:r=>{E(r,o,t);let u=[];for(let c of e){let d=n(c),x=r.subarray(0,d);u.push(typeof c=="number"?x:c.decode(x)),r=r.subarray(d)}return u}}}function ct(t,e){let n=e*t.bytesLen;return{bytesLen:n,encode:o=>{if(o.length!==e)throw new Error(`vecCoder.encode: wrong length=${o.length}. Expected: ${e}`);let r=new Uint8Array(n);for(let u=0,c=0;u<o.length;u++){let d=t.encode(o[u]);r.set(d,c),d.fill(0),c+=d.length}return r},decode:o=>{E(o,n);let r=[];for(let u=0;u<o.length;u+=t.bytesLen)r.push(t.decode(o.subarray(u,u+t.bytesLen)));return r}}}function z(...t){for(let e of t)if(Array.isArray(e))for(let n of e)n.fill(0);else e.fill(0)}function $t(t){return(1<<t)-1}var _e=Uint8Array.of();function Yt(t,e=_e){if(E(t),E(e),e.length>255)throw new Error("context should be less than 255 bytes");return St(new Uint8Array([0,e.length]),e,t)}var Xe=Uint8Array.from([6,9,96,134,72,1,101,3,4,2]);function Le(t,e=0){if(!t.oid||!Gt(t.oid.subarray(0,10),Xe))throw new Error("hash.oid is invalid: expected NIST hash");let n=t.outputLen*8/2;if(e>n)throw new Error("Pre-hash security strength too low: "+n+", required: "+e)}function Xt(t,e,n=_e){if(E(e),E(n),n.length>255)throw new Error("context should be less than 255 bytes");let o=t(e);return St(new Uint8Array([1,n.length]),n,t.oid,o)}var Ie=t=>{let{newPoly:e,N:n,Q:o,F:r,ROOT_OF_UNITY:u,brvBits:c,isKyber:d}=t,x=(p,w=o)=>{let I=p%w|0;return(I>=0?I|0:w+I|0)|0},A=(p,w=o)=>{let I=x(p,w)|0;return(I>w>>1?I-w|0:I)|0};function g(){let p=e(n);for(let w=0;w<n;w++){let I=Nt(w,c),Y=BigInt(u)**BigInt(I)%BigInt(o);p[w]=Number(Y)|0}return p}let S=g(),W={add:(p,w)=>x((p|0)+(w|0))|0,sub:(p,w)=>x((p|0)-(w|0))|0,mul:(p,w)=>x((p|0)*(w|0))|0,inv:p=>{throw new Error("not implemented")}},R={N:n,roots:S,invertButterflies:!0,skipStages:d?1:0,brp:!1},V=jt(W,{dit:!1,...R}),tt=jt(W,{dit:!0,...R});return{mod:x,smod:A,nttZetas:S,NTT:{encode:p=>V(p),decode:p=>{tt(p);for(let w=0;w<p.length;w++)p[w]=x(r*p[w]);return p}},bitsCoder:(p,w)=>{let I=$t(p),Y=p*(n/8);return{bytesLen:Y,encode:N=>{let X=new Uint8Array(Y);for(let C=0,B=0,v=0,lt=0;C<N.length;C++)for(B|=(w.encode(N[C])&I)<<v,v+=p;v>=8;v-=8,B>>=8)X[lt++]=B&$t(v);return X},decode:N=>{let X=e(n);for(let C=0,B=0,v=0,lt=0;C<N.length;C++)for(B|=N[C]<<v,v+=8;v>=p;v-=p,B>>=p)X[lt++]=w.decode(B&I);return X}}}}},Me=t=>(e,n)=>{n||(n=t.blockLen);let o=new Uint8Array(e.length+2);o.set(e);let r=e.length,u=new Uint8Array(n),c=t.create({}),d=0,x=0;return{stats:()=>({calls:d,xofs:x}),get:(A,g)=>(o[r+0]=A,o[r+1]=g,c.destroy(),c=t.create({}).update(o),d++,()=>(x++,c.xofInto(u))),clean:()=>{c.destroy(),z(u,o)}}},kt=Me(Be),Ot=Me(H);function Ue(t){Kt(t),t.externalMu!==void 0&&ge(t.externalMu,"opts.externalMu")}var b=256,rt=8380417,De=1753,Ze=8347681,ft=13,Dt=Math.floor((rt-1)/88)|0,Zt=Math.floor((rt-1)/32)|0,qt={2:{K:4,L:4,D:ft,GAMMA1:2**17,GAMMA2:Dt,TAU:39,ETA:2,OMEGA:80},3:{K:6,L:5,D:ft,GAMMA1:2**19,GAMMA2:Zt,TAU:49,ETA:4,OMEGA:55},5:{K:8,L:7,D:ft,GAMMA1:2**19,GAMMA2:Zt,TAU:60,ETA:2,OMEGA:75}},G=t=>new Int32Array(t),{mod:it,smod:Lt,NTT:L,bitsCoder:qe}=Ie({N:b,Q:rt,F:Ze,ROOT_OF_UNITY:De,newPoly:G,isKyber:!1,brvBits:8}),Ce=t=>t,gt=(t,e=Ce,n=Ce)=>qe(t,{encode:o=>e(n(o)),decode:o=>n(e(o))}),nt=(t,e)=>{for(let n=0;n<t.length;n++)t[n]=it(t[n]+e[n]);return t},ve=(t,e)=>{for(let n=0;n<t.length;n++)t[n]=it(t[n]-e[n]);return t},ze=t=>{for(let e=0;e<b;e++)t[e]<<=ft;return t},yt=(t,e)=>{for(let n=0;n<b;n++)if(Math.abs(Lt(t[n]))>=e)return!0;return!1},ot=(t,e)=>{let n=G(b);for(let o=0;o<t.length;o++)n[o]=it(t[o]*e[o]);return n};function _t(t){let e=G(b);for(let n=0;n<b;){let o=t();if(o.length%3)throw new Error("RejNTTPoly: unaligned block");for(let r=0;n<b&&r<=o.length-3;r+=3){let u=(o[r+0]|o[r+1]<<8|o[r+2]<<16)&8388607;u<rt&&(e[n++]=u)}}return e}function zt(t){let{K:e,L:n,GAMMA1:o,GAMMA2:r,TAU:u,ETA:c,OMEGA:d}=t,{CRH_BYTES:x,TR_BYTES:A,C_TILDE_BYTES:g,XOF128:S,XOF256:W,securityLevel:R}=t;if(![2,4].includes(c))throw new Error("Wrong ETA");if(![1<<17,1<<19].includes(o))throw new Error("Wrong GAMMA1");if(![Dt,Zt].includes(r))throw new Error("Wrong GAMMA2");let V=u*c,tt=s=>{let l=it(s),i=Lt(l,2*r)|0;return l-i===rt-1?{r1:0,r0:i-1|0}:{r1:Math.floor((l-i)/(2*r))|0,r0:i}},xt=s=>tt(s).r1,st=s=>tt(s).r0,p=(s,l)=>s<=r||s>rt-r||s===rt-r&&l===0?0:1,w=(s,l)=>{let i=Math.floor((rt-1)/(2*r)),{r1:f,r0:h}=tt(l);return s===1?h>0?it(f+1,i)|0:it(f-1,i)|0:f|0},I=s=>{let l=it(s),i=Lt(l,2**ft)|0;return{r1:Math.floor((l-i)/2**ft)|0,r0:i}},Y={bytesLen:d+e,encode:s=>{if(s===!1)throw new Error("hint.encode: hint is false");let l=new Uint8Array(d+e);for(let i=0,f=0;i<e;i++){for(let h=0;h<b;h++)s[i][h]!==0&&(l[f++]=h);l[d+i]=f}return l},decode:s=>{let l=[],i=0;for(let f=0;f<e;f++){let h=G(b);if(s[d+f]<i||s[d+f]>d)return!1;for(let y=i;y<s[d+f];y++){if(y>i&&s[y]<=s[y-1])return!1;h[s[y]]=1}i=s[d+f],l.push(h)}for(let f=i;f<d;f++)if(s[f]!==0)return!1;return l}},N=gt(c===2?3:4,s=>c-s,s=>{if(!(-c<=s&&s<=c))throw new Error(`malformed key s1/s3 ${s} outside of ETA range [${-c}, ${c}]`);return s}),X=gt(13,s=>(1<<ft-1)-s),C=gt(10),B=gt(o===1<<17?18:20,s=>Lt(o-s)),v=gt(r===Dt?6:4),lt=ct(v,e),wt=pt("publicKey",32,ct(C,e)),mt=pt("secretKey",32,32,A,ct(N,n),ct(N,e),ct(X,e)),bt=pt("signature",g,ct(B,n),Y),Wt=c===2?s=>s<15?2-s%5:!1:s=>s<9?4-s:!1;function Vt(s){let l=G(b);for(let i=0;i<b;){let f=s();for(let h=0;i<b&&h<f.length;h+=1){let y=Wt(f[h]&15),M=Wt(f[h]>>4&15);y!==!1&&(l[i++]=y),i<b&&M!==!1&&(l[i++]=M)}}return l}let Qt=s=>{let l=G(b),i=H.create({}).update(s),f=new Uint8Array(H.blockLen);i.xofInto(f);let h=f.slice(0,8);for(let y=b-u,M=8,P=0,T=0;y<b;y++){let k=y+1;for(;k>y;)k=f[M++],!(M<H.blockLen)&&(i.xofInto(f),M=0);l[y]=l[k],l[k]=1-((h[P]>>T++&1)<<1),T>=8&&(P++,T=0)}return l},Jt=s=>{let l=G(b),i=G(b);for(let f=0;f<s.length;f++){let{r0:h,r1:y}=I(s[f]);l[f]=h,i[f]=y}return{r0:l,r1:i}},Se=(s,l)=>{for(let i=0;i<b;i++)s[i]=w(l[i],s[i]);return s},Re=(s,l)=>{let i=G(b),f=0;for(let h=0;h<b;h++){let y=p(s[h],l[h]);i[h]=y,f+=y}return{v:i,cnt:f}},te=32,ee=pt("seed",32,64,32),D={info:{type:"internal-ml-dsa"},lengths:{secretKey:mt.bytesLen,publicKey:wt.bytesLen,seed:32,signature:bt.bytesLen,signRand:te},keygen:s=>{let l=new Uint8Array(34),i=s===void 0;i&&(s=Ft(32)),E(s,32,"seed"),l.set(s),i&&z(s),l[32]=e,l[33]=n;let[f,h,y]=ee.decode(H(l,{dkLen:ee.bytesLen})),M=W(h),P=[];for(let a=0;a<n;a++)P.push(Vt(M.get(a&255,a>>8&255)));let T=[];for(let a=n;a<n+e;a++)T.push(Vt(M.get(a&255,a>>8&255)));let k=P.map(a=>L.encode(a.slice())),O=[],U=[],Q=S(f),_=G(b);for(let a=0;a<e;a++){z(_);for(let F=0;F<n;F++){let q=_t(Q.get(F,a));nt(_,ot(q,k[F]))}L.decode(_);let{r0:K,r1:j}=Jt(nt(_,T[a]));O.push(K),U.push(j)}let Z=wt.encode([f,U]),J=H(Z,{dkLen:A}),ut=mt.encode([f,y,J,P,T,O]);return Q.clean(),M.clean(),z(f,h,y,P,T,k,_,O,U,J,l),{publicKey:Z,secretKey:ut}},getPublicKey:s=>{let[l,i,f,h,y,M]=mt.decode(s),P=S(l),T=h.map(U=>L.encode(U.slice())),k=[],O=G(b);for(let U=0;U<e;U++){O.fill(0);for(let _=0;_<n;_++){let Z=_t(P.get(_,U));nt(O,ot(Z,T[_]))}L.decode(O),nt(O,y[U]);let{r1:Q}=Jt(O);k.push(Q)}return P.clean(),z(O,T,M,h,y),wt.encode([l,k])},sign:(s,l,i={})=>{Tt(i),Ue(i);let{extraEntropy:f,externalMu:h=!1}=i,[y,M,P,T,k,O]=mt.decode(l),U=[],Q=S(y);for(let a=0;a<e;a++){let K=[];for(let j=0;j<n;j++)K.push(_t(Q.get(j,a)));U.push(K)}Q.clean();for(let a=0;a<n;a++)L.encode(T[a]);for(let a=0;a<e;a++)L.encode(k[a]),L.encode(O[a]);let _=h?s:H.create({dkLen:x}).update(P).update(s).digest(),Z=f===!1?new Uint8Array(32):f===void 0?Ft(te):f;E(Z,32,"extraEntropy");let J=H.create({dkLen:x}).update(M).update(Z).update(_).digest();E(J,x);let ut=W(J,B.bytesLen);t:for(let a=0;;){let K=[];for(let m=0;m<n;m++,a++)K.push(B.decode(ut.get(a&255,a>>8)()));let j=K.map(m=>L.encode(m.slice())),F=[];for(let m=0;m<e;m++){let dt=G(b);for(let et=0;et<n;et++)nt(dt,ot(U[m][et],j[et]));L.decode(dt),F.push(dt)}let q=F.map(m=>m.map(xt)),at=H.create({dkLen:g}).update(_).update(lt.encode(q)).digest(),Et=L.encode(Qt(at)),At=T.map(m=>ot(m,Et));for(let m=0;m<n;m++)if(nt(L.decode(At[m]),K[m]),yt(At[m],o-V))continue t;let ne=0,It=[];for(let m=0;m<e;m++){let dt=L.decode(ot(k[m],Et)),et=ve(F[m],dt).map(st);if(yt(et,r-V))continue t;let oe=L.decode(ot(O[m],Et));if(yt(oe,r))continue t;nt(et,oe);let re=Re(et,q[m]);It.push(re.v),ne+=re.cnt}if(ne>d)continue;ut.clean();let Pe=bt.encode([at,At,It]);return z(at,At,It,Et,q,F,j,K,J,_,T,k,O,...U),Pe}throw new Error("Unreachable code path reached, report this error")},verify:(s,l,i,f={})=>{Ue(f);let{externalMu:h=!1}=f,[y,M]=wt.decode(i),P=H(i,{dkLen:A});if(s.length!==bt.bytesLen)return!1;let[T,k,O]=bt.decode(s);if(O===!1)return!1;for(let a=0;a<n;a++)if(yt(k[a],o-V))return!1;let U=h?l:H.create({dkLen:x}).update(P).update(l).digest(),Q=L.encode(Qt(T)),_=k.map(a=>a.slice());for(let a=0;a<n;a++)L.encode(_[a]);let Z=[],J=S(y);for(let a=0;a<e;a++){let K=ot(L.encode(ze(M[a])),Q),j=G(b);for(let q=0;q<n;q++){let at=_t(J.get(q,a));nt(j,ot(at,_[q]))}let F=L.decode(ve(j,K));Z.push(Se(F,O[a]))}J.clean();let ut=H.create({dkLen:g}).update(U).update(lt.encode(Z)).digest();for(let a of O)if(!(a.reduce((j,F)=>j+F,0)<=d))return!1;for(let a of k)if(yt(a,o-V))return!1;return Gt(T,ut)}};return{info:{type:"ml-dsa"},internal:D,securityLevel:R,keygen:D.keygen,lengths:D.lengths,getPublicKey:D.getPublicKey,sign:(s,l,i={})=>{Tt(i);let f=Yt(s,i.context),h=D.sign(f,l,i);return z(f),h},verify:(s,l,i,f={})=>(Bt(f),D.verify(s,Yt(l,f.context),i)),prehash:s=>(Le(s,R),{info:{type:"hashml-dsa"},securityLevel:R,lengths:D.lengths,keygen:D.keygen,getPublicKey:D.getPublicKey,sign:(l,i,f={})=>{Tt(f);let h=Xt(s,l,f.context),y=D.sign(h,i,f);return z(h),y},verify:(l,i,f,h={})=>(Bt(h),D.verify(l,Xt(s,i,h.context),f))})}}var pn=zt({...qt[2],CRH_BYTES:64,TR_BYTES:64,C_TILDE_BYTES:32,XOF128:kt,XOF256:Ot,securityLevel:128}),gn=zt({...qt[3],CRH_BYTES:64,TR_BYTES:64,C_TILDE_BYTES:48,XOF128:kt,XOF256:Ot,securityLevel:192}),yn=zt({...qt[5],CRH_BYTES:64,TR_BYTES:64,C_TILDE_BYTES:64,XOF128:kt,XOF256:Ot,securityLevel:256});export{qt as PARAMS,pn as ml_dsa44,gn as ml_dsa65,yn as ml_dsa87};
/*! Bundled license information:

@noble/curves/utils.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/post-quantum/utils.js:
@noble/post-quantum/_crystals.js:
@noble/post-quantum/ml-dsa.js:
  (*! noble-post-quantum - MIT License (c) 2024 Paul Miller (paulmillr.com) *)
*/
