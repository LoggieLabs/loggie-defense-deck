<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Intake Admin</title>
  <style>
    :root {
      --bg: #0d1117; --surface: #161b22; --border: #30363d;
      --text: #e6edf3; --dim: #8b949e; --accent: #58a6ff;
      --green: #3fb950; --red: #f85149; --yellow: #d29922;
      --font: ui-monospace, 'SF Mono', 'Cascadia Code', monospace;
    }
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body { font-family: var(--font); background: var(--bg); color: var(--text); font-size: 14px; line-height: 1.5; }
    a { color: var(--accent); text-decoration: none; }
    a:hover { text-decoration: underline; }

    .header { padding: 16px 24px; border-bottom: 1px solid var(--border); display: flex; align-items: center; gap: 16px; }
    .header h1 { font-size: 16px; font-weight: 600; }
    .header .badge { font-size: 11px; background: var(--accent); color: var(--bg); padding: 2px 8px; border-radius: 10px; }

    .container { max-width: 1200px; margin: 0 auto; padding: 24px; }

    /* Key status bar */
    .key-bar { display: flex; align-items: center; gap: 12px; padding: 12px 16px; background: var(--surface); border: 1px solid var(--border); border-radius: 6px; margin-bottom: 24px; }
    .key-bar .dot { width: 8px; height: 8px; border-radius: 50%; background: var(--red); }
    .key-bar .dot.loaded { background: var(--green); }
    .key-bar label { cursor: pointer; color: var(--accent); font-size: 13px; }
    .key-bar label:hover { text-decoration: underline; }
    .key-bar input[type="file"] { display: none; }
    .key-bar .info { color: var(--dim); font-size: 12px; margin-left: auto; }

    /* Table */
    table { width: 100%; border-collapse: collapse; }
    th { text-align: left; padding: 8px 12px; color: var(--dim); font-size: 12px; text-transform: uppercase; letter-spacing: 0.05em; border-bottom: 1px solid var(--border); }
    td { padding: 8px 12px; border-bottom: 1px solid var(--border); font-size: 13px; }
    tr:hover td { background: var(--surface); }
    tr { cursor: pointer; }

    .status { display: inline-block; padding: 1px 6px; border-radius: 3px; font-size: 11px; font-weight: 600; }
    .status-new { background: rgba(88,166,255,0.15); color: var(--accent); }
    .status-processed { background: rgba(63,185,80,0.15); color: var(--green); }

    .id-cell { font-family: var(--font); font-size: 12px; color: var(--dim); }

    /* Controls */
    .controls { display: flex; gap: 8px; align-items: center; margin-bottom: 16px; flex-wrap: wrap; }
    .search { padding: 6px 12px; background: var(--surface); border: 1px solid var(--border); border-radius: 6px; color: var(--text); font-family: var(--font); font-size: 13px; width: 300px; }
    .search:focus { outline: none; border-color: var(--accent); }

    button, .btn { padding: 6px 14px; border-radius: 6px; border: 1px solid var(--border); background: var(--surface); color: var(--text); font-family: var(--font); font-size: 13px; cursor: pointer; }
    button:hover, .btn:hover { border-color: var(--dim); }
    button:disabled { opacity: 0.4; cursor: not-allowed; }
    .btn-primary { background: var(--accent); color: var(--bg); border-color: var(--accent); }
    .btn-primary:hover { opacity: 0.9; }
    .btn-green { background: var(--green); color: var(--bg); border-color: var(--green); }
    .btn-red { background: transparent; color: var(--red); border-color: var(--red); }

    .pagination { display: flex; gap: 8px; margin-top: 16px; justify-content: center; }

    /* Detail view */
    .detail { display: none; }
    .detail.active { display: block; }
    .list.hidden { display: none; }

    .back { display: inline-flex; align-items: center; gap: 4px; margin-bottom: 16px; color: var(--dim); font-size: 13px; cursor: pointer; }
    .back:hover { color: var(--text); }

    .meta-grid { display: grid; grid-template-columns: 140px 1fr; gap: 4px 16px; padding: 16px; background: var(--surface); border: 1px solid var(--border); border-radius: 6px; margin-bottom: 16px; }
    .meta-grid dt { color: var(--dim); font-size: 12px; }
    .meta-grid dd { font-size: 13px; word-break: break-all; }

    .decrypt-panel { padding: 16px; background: var(--surface); border: 1px solid var(--border); border-radius: 6px; margin-bottom: 16px; }
    .decrypt-panel h3 { font-size: 14px; margin-bottom: 12px; }
    .decrypt-output { width: 100%; min-height: 200px; max-height: 500px; overflow: auto; padding: 12px; background: var(--bg); border: 1px solid var(--border); border-radius: 4px; font-family: var(--font); font-size: 12px; color: var(--text); white-space: pre-wrap; word-break: break-word; margin-top: 12px; }

    .workflow { padding: 16px; background: var(--surface); border: 1px solid var(--border); border-radius: 6px; }
    .workflow h3 { font-size: 14px; margin-bottom: 12px; }
    .workflow .actions { display: flex; gap: 8px; margin-bottom: 12px; }
    textarea { width: 100%; padding: 8px; background: var(--bg); border: 1px solid var(--border); border-radius: 4px; color: var(--text); font-family: var(--font); font-size: 13px; resize: vertical; min-height: 60px; }
    textarea:focus { outline: none; border-color: var(--accent); }

    .toast { position: fixed; bottom: 24px; right: 24px; padding: 10px 20px; background: var(--green); color: var(--bg); border-radius: 6px; font-size: 13px; opacity: 0; transition: opacity 0.3s; pointer-events: none; z-index: 100; }
    .toast.show { opacity: 1; }
    .toast.error { background: var(--red); }

    .loading { color: var(--dim); padding: 40px; text-align: center; }
    .empty { color: var(--dim); padding: 40px; text-align: center; font-style: italic; }
  </style>
</head>
<body>

<div class="header">
  <h1>Secure Intake Admin</h1>
  <span class="badge">sealed boundary</span>
</div>

<div class="container">
  <!-- Key file loader -->
  <div class="key-bar">
    <div class="dot" id="keyDot"></div>
    <span id="keyLabel">No key loaded</span>
    <label>Load key file<input type="file" id="keyFile" accept=".json"></label>
    <button id="clearKey" style="display:none" class="btn-red">Clear key</button>
    <span class="info">Key stays in memory only. Never uploaded.</span>
  </div>

  <!-- List view -->
  <div class="list" id="listView">
    <div class="controls">
      <input class="search" id="search" type="text" placeholder="Filter by ID...">
      <button id="refreshBtn">Refresh</button>
    </div>
    <table>
      <thead>
        <tr>
          <th>Received</th>
          <th>ID</th>
          <th>Status</th>
          <th>Size</th>
          <th>Ref</th>
          <th>Processed</th>
        </tr>
      </thead>
      <tbody id="listBody"></tbody>
    </table>
    <div class="pagination" id="pagination"></div>
  </div>

  <!-- Detail view -->
  <div class="detail" id="detailView">
    <div class="back" id="backBtn">&larr; Back to list</div>

    <dl class="meta-grid" id="metaGrid"></dl>

    <div class="decrypt-panel">
      <h3>Decryption</h3>
      <div style="display:flex;gap:8px;">
        <button id="decryptBtn" disabled>Decrypt locally</button>
        <button id="exportBtn" disabled>Export decrypted JSON</button>
      </div>
      <div class="decrypt-output" id="decryptOutput" style="display:none"></div>
    </div>

    <div class="workflow">
      <h3>Workflow</h3>
      <div class="actions">
        <button id="markProcessedBtn" class="btn-green">Mark processed</button>
        <button id="unprocessBtn" class="btn-red">Unprocess</button>
      </div>
      <textarea id="noteInput" placeholder="Add a note..."></textarea>
      <div style="margin-top:8px;">
        <button id="saveNoteBtn">Save note</button>
      </div>
    </div>
  </div>
</div>

<div class="toast" id="toast"></div>

<!-- tweetnacl (UMD) -->
<script src="https://cdn.jsdelivr.net/npm/tweetnacl@1.0.3/nacl-fast.min.js"></script>

<script>
(function() {
  "use strict";

  // ═══════════════════════════════════════════════════════════════════════════
  // CRYPTO PRIMITIVES (ported from pqc-shared, browser-only)
  // ═══════════════════════════════════════════════════════════════════════════

  const te = new TextEncoder();
  const td = new TextDecoder();

  function toB64(bytes) {
    let s = "";
    for (let i = 0; i < bytes.length; i++) s += String.fromCharCode(bytes[i]);
    return btoa(s);
  }

  function fromB64(str) {
    const bin = atob(str);
    const out = new Uint8Array(bin.length);
    for (let i = 0; i < bin.length; i++) out[i] = bin.charCodeAt(i);
    return out;
  }

  function toHex(bytes) {
    return Array.from(bytes).map(b => b.toString(16).padStart(2, "0")).join("");
  }

  function fromHex(hex) {
    const s = hex.startsWith("0x") ? hex.slice(2) : hex;
    const n = s.length % 2 ? "0" + s : s;
    const out = new Uint8Array(n.length / 2);
    for (let i = 0; i < out.length; i++) out[i] = parseInt(n.slice(i*2, i*2+2), 16);
    return out;
  }

  // HMAC-SHA256 using Web Crypto
  async function hmacSha256(key, data) {
    const k = await crypto.subtle.importKey("raw", key, { name: "HMAC", hash: "SHA-256" }, false, ["sign"]);
    return new Uint8Array(await crypto.subtle.sign("HMAC", k, data));
  }

  // HKDF-SHA256 (Extract + Expand, RFC 5869)
  async function hkdfSha256(ikm, salt, info, length) {
    salt = salt || new Uint8Array(32);
    info = info || new Uint8Array(0);
    length = length || 32;
    if (typeof salt === "string") salt = te.encode(salt);
    if (typeof info === "string") info = te.encode(info);

    // Extract
    const prk = await hmacSha256(salt, ikm);

    // Expand
    let t = new Uint8Array(0);
    const chunks = [];
    for (let i = 1; i <= Math.ceil(length / 32); i++) {
      const input = new Uint8Array(t.length + info.length + 1);
      input.set(t, 0);
      input.set(info, t.length);
      input[input.length - 1] = i;
      t = await hmacSha256(prk, input);
      chunks.push(t);
    }

    const out = new Uint8Array(length);
    let off = 0;
    for (const c of chunks) {
      out.set(c.subarray(0, length - off), off);
      off += c.length;
      if (off >= length) break;
    }
    return out;
  }

  // ═══════════════════════════════════════════════════════════════════════════
  // HYBRID DECRYPTION (browser-only, from pqc-shared/crypto/hybrid.ts)
  // ═══════════════════════════════════════════════════════════════════════════

  const SUPPORTED_VERSIONS = ["omnituum.hybrid.v1", "pqc-demo.hybrid.v1"];

  /**
   * Decrypt a HybridEnvelope using X25519.
   * Kyber decapsulation is attempted if kyber-crystals is available,
   * otherwise falls back to X25519 only.
   */
  async function hybridDecrypt(envelope, secretKeys) {
    if (!SUPPORTED_VERSIONS.includes(envelope.v)) {
      throw new Error("Unsupported envelope version: " + envelope.v);
    }

    const saltPrefix = envelope.v === "pqc-demo.hybrid.v1" ? "pqc-demo" : "omnituum";
    let CK = null;

    // Try Kyber if library is loaded
    if (window._kyberDecapsulate) {
      try {
        const kyberShared = await window._kyberDecapsulate(envelope.kyberKemCt, secretKeys.kyberSecB64);
        const kyberKek = await hkdfSha256(kyberShared, saltPrefix + "/kyber", "wrap-ck", 32);
        CK = nacl.secretbox.open(
          fromB64(envelope.kyberWrap.wrapped),
          fromB64(envelope.kyberWrap.nonce),
          kyberKek
        );
      } catch (e) {
        console.warn("[Decrypt] Kyber failed, trying X25519:", e);
      }
    }

    // Fall back to X25519
    if (!CK) {
      try {
        const ephPk = fromHex(envelope.x25519Epk);
        const sk = fromHex(secretKeys.x25519SecHex);
        const shared = nacl.scalarMult(sk, ephPk);
        const kek = await hkdfSha256(shared, saltPrefix + "/x25519", "wrap-ck", 32);
        CK = nacl.secretbox.open(
          fromB64(envelope.x25519Wrap.wrapped),
          fromB64(envelope.x25519Wrap.nonce),
          kek
        );
      } catch (e) {
        console.warn("[Decrypt] X25519 failed:", e);
      }
    }

    if (!CK) throw new Error("Could not unwrap content key");

    const pt = nacl.secretbox.open(
      fromB64(envelope.ciphertext),
      fromB64(envelope.contentNonce),
      CK
    );

    if (!pt) throw new Error("Content authentication failed");

    return td.decode(pt);
  }

  // ═══════════════════════════════════════════════════════════════════════════
  // IDENTITY KEY PARSING
  // ═══════════════════════════════════════════════════════════════════════════

  /**
   * Parse an identity JSON file into secret keys.
   * Supports:
   *   - Flat HybridIdentity format (x25519SecHex, kyberSecB64 at root)
   *   - Nested golden format (keys.x25519.secret, keys.kyber.secret)
   *   - Vault format (identities[0] with keys)
   */
  function parseIdentityKeys(json) {
    // Flat format (HybridIdentity)
    if (json.x25519SecHex && json.kyberSecB64) {
      return { x25519SecHex: json.x25519SecHex, kyberSecB64: json.kyberSecB64 };
    }

    // Nested key format (golden test / org.identity.json)
    if (json.keys) {
      const x = json.keys.x25519;
      const k = json.keys.kyber;
      if (x && x.secret && k && k.secret) {
        return { x25519SecHex: x.secret, kyberSecB64: k.secret };
      }
    }

    // Vault format (decrypted vault with identities array)
    if (json.identities && Array.isArray(json.identities) && json.identities.length > 0) {
      const id = json.identities[0];
      if (id.x25519SecHex && id.kyberSecB64) {
        return { x25519SecHex: id.x25519SecHex, kyberSecB64: id.kyberSecB64 };
      }
    }

    throw new Error("Unrecognized identity file format");
  }

  function parseIdentityName(json) {
    return json.identity?.name || json.name || json.identities?.[0]?.name || "Unknown";
  }

  // ═══════════════════════════════════════════════════════════════════════════
  // STATE
  // ═══════════════════════════════════════════════════════════════════════════

  let secretKeys = null;     // In-memory only, never persisted
  let currentItem = null;    // Currently viewed item (with encrypted_json)
  let decryptedText = null;  // Decrypted plaintext (in memory only)
  let allItems = [];         // Current page items
  let nextCursor = null;
  let cursorStack = [];      // For back pagination

  // ═══════════════════════════════════════════════════════════════════════════
  // DOM REFS
  // ═══════════════════════════════════════════════════════════════════════════

  const $ = (id) => document.getElementById(id);

  // ═══════════════════════════════════════════════════════════════════════════
  // API
  // ═══════════════════════════════════════════════════════════════════════════

  async function api(path, opts) {
    const res = await fetch("/api/admin/intake" + path, {
      headers: { "Content-Type": "application/json" },
      ...opts,
    });
    const data = await res.json();
    if (!data.ok) throw new Error(data.error || "API error");
    return data;
  }

  // ═══════════════════════════════════════════════════════════════════════════
  // TOAST
  // ═══════════════════════════════════════════════════════════════════════════

  function toast(msg, isError) {
    const el = $("toast");
    el.textContent = msg;
    el.className = "toast show" + (isError ? " error" : "");
    setTimeout(() => el.className = "toast", 2500);
  }

  // ═══════════════════════════════════════════════════════════════════════════
  // KEY MANAGEMENT
  // ═══════════════════════════════════════════════════════════════════════════

  $("keyFile").addEventListener("change", async (e) => {
    const file = e.target.files[0];
    if (!file) return;
    try {
      const text = await file.text();
      const json = JSON.parse(text);
      secretKeys = parseIdentityKeys(json);
      const name = parseIdentityName(json);
      $("keyDot").classList.add("loaded");
      $("keyLabel").textContent = "Key loaded: " + name;
      $("clearKey").style.display = "";
      $("decryptBtn").disabled = !currentItem;
      toast("Key loaded (in memory only)");
    } catch (err) {
      toast("Failed to parse key file: " + err.message, true);
    }
    e.target.value = ""; // allow re-selecting same file
  });

  $("clearKey").addEventListener("click", () => {
    secretKeys = null;
    decryptedText = null;
    $("keyDot").classList.remove("loaded");
    $("keyLabel").textContent = "No key loaded";
    $("clearKey").style.display = "none";
    $("decryptBtn").disabled = true;
    $("exportBtn").disabled = true;
    $("decryptOutput").style.display = "none";
    $("decryptOutput").textContent = "";
    toast("Key cleared from memory");
  });

  // ═══════════════════════════════════════════════════════════════════════════
  // LIST VIEW
  // ═══════════════════════════════════════════════════════════════════════════

  async function loadList(cursor) {
    const body = $("listBody");
    body.innerHTML = '<tr><td colspan="6" class="loading">Loading...</td></tr>';
    try {
      const params = new URLSearchParams({ limit: "50" });
      if (cursor) params.set("cursor", cursor);
      const data = await api("?" + params.toString());
      allItems = data.items || [];
      nextCursor = data.nextCursor || null;
      renderList();
    } catch (err) {
      body.innerHTML = '<tr><td colspan="6" class="empty">Error: ' + escHtml(err.message) + '</td></tr>';
    }
  }

  function renderList() {
    const body = $("listBody");
    const filter = $("search").value.toLowerCase();
    const filtered = filter ? allItems.filter(it => it.id.includes(filter)) : allItems;

    if (!filtered.length) {
      body.innerHTML = '<tr><td colspan="6" class="empty">No submissions found</td></tr>';
      $("pagination").innerHTML = "";
      return;
    }

    body.innerHTML = filtered.map(it => `
      <tr data-id="${it.id}">
        <td>${escHtml(formatDate(it.received_at))}</td>
        <td class="id-cell" title="${it.id}">${it.id.slice(0,12)}…</td>
        <td><span class="status status-${it.status || 'new'}">${it.status || 'new'}</span></td>
        <td>${formatSize(it.ciphertext_len)}</td>
        <td>${escHtml(it.ref || '—')}</td>
        <td>${it.processed_at ? escHtml(formatDate(it.processed_at)) : '—'}</td>
      </tr>
    `).join("");

    // Row click
    body.querySelectorAll("tr[data-id]").forEach(row => {
      row.addEventListener("click", () => openDetail(row.dataset.id));
    });

    // Pagination
    const pag = $("pagination");
    pag.innerHTML = "";
    if (cursorStack.length > 0) {
      const btn = document.createElement("button");
      btn.textContent = "Previous";
      btn.addEventListener("click", () => {
        const prev = cursorStack.pop();
        loadList(prev);
      });
      pag.appendChild(btn);
    }
    if (nextCursor) {
      const btn = document.createElement("button");
      btn.textContent = "Next";
      btn.addEventListener("click", () => {
        cursorStack.push(null); // save current position
        loadList(nextCursor);
      });
      pag.appendChild(btn);
    }
  }

  $("search").addEventListener("input", renderList);
  $("refreshBtn").addEventListener("click", () => {
    cursorStack = [];
    loadList();
  });

  // ═══════════════════════════════════════════════════════════════════════════
  // DETAIL VIEW
  // ═══════════════════════════════════════════════════════════════════════════

  async function openDetail(id) {
    $("listView").classList.add("hidden");
    $("detailView").classList.add("active");
    $("decryptOutput").style.display = "none";
    $("decryptOutput").textContent = "";
    $("exportBtn").disabled = true;
    decryptedText = null;
    currentItem = null;

    const grid = $("metaGrid");
    grid.innerHTML = '<dt>Loading...</dt><dd></dd>';

    try {
      const data = await api("/" + id);
      currentItem = data.item;
      renderDetail();
    } catch (err) {
      grid.innerHTML = '<dt>Error</dt><dd>' + escHtml(err.message) + '</dd>';
    }
  }

  function renderDetail() {
    const it = currentItem;
    if (!it) return;

    const fields = [
      ["ID", it.id],
      ["Version", it.v],
      ["Received", formatDate(it.received_at)],
      ["Status", it.status || "new"],
      ["Ciphertext size", formatSize(it.encrypted_json?.length || 0)],
      ["IP hash", it.ip_hash || "—"],
      ["User agent", it.ua || "—"],
      ["Referrer", it.ref || "—"],
      ["Viewed at", it.viewed_at ? formatDate(it.viewed_at) : "—"],
      ["Processed at", it.processed_at ? formatDate(it.processed_at) : "—"],
      ["Note", it.note || "—"],
    ];

    $("metaGrid").innerHTML = fields.map(([k,v]) =>
      `<dt>${escHtml(k)}</dt><dd>${escHtml(String(v))}</dd>`
    ).join("");

    $("decryptBtn").disabled = !secretKeys;
    $("noteInput").value = it.note || "";

    // Update workflow buttons
    $("markProcessedBtn").disabled = it.status === "processed";
    $("unprocessBtn").disabled = it.status !== "processed";
  }

  $("backBtn").addEventListener("click", () => {
    $("detailView").classList.remove("active");
    $("listView").classList.remove("hidden");
    currentItem = null;
    decryptedText = null;
    $("decryptOutput").style.display = "none";
    $("decryptOutput").textContent = "";
    loadList(); // refresh to see updated status
  });

  // ═══════════════════════════════════════════════════════════════════════════
  // DECRYPT
  // ═══════════════════════════════════════════════════════════════════════════

  $("decryptBtn").addEventListener("click", async () => {
    if (!secretKeys || !currentItem) return;
    $("decryptBtn").disabled = true;
    $("decryptBtn").textContent = "Decrypting...";
    try {
      const envelope = JSON.parse(currentItem.encrypted_json);
      const plaintext = await hybridDecrypt(envelope, secretKeys);

      // Try to pretty-print JSON
      try {
        const parsed = JSON.parse(plaintext);
        decryptedText = JSON.stringify(parsed, null, 2);
      } catch {
        decryptedText = plaintext;
      }

      $("decryptOutput").textContent = decryptedText;
      $("decryptOutput").style.display = "block";
      $("exportBtn").disabled = false;
      toast("Decrypted locally (plaintext is in browser memory only)");
    } catch (err) {
      $("decryptOutput").textContent = "Decryption failed: " + err.message;
      $("decryptOutput").style.display = "block";
      toast("Decryption failed: " + err.message, true);
    }
    $("decryptBtn").textContent = "Decrypt locally";
    $("decryptBtn").disabled = false;
  });

  $("exportBtn").addEventListener("click", () => {
    if (!decryptedText || !currentItem) return;
    const blob = new Blob([decryptedText], { type: "application/json" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = "intake-" + currentItem.id.slice(0, 12) + "-decrypted.json";
    a.click();
    URL.revokeObjectURL(url);
    toast("Exported (local download only)");
  });

  // ═══════════════════════════════════════════════════════════════════════════
  // WORKFLOW ACTIONS
  // ═══════════════════════════════════════════════════════════════════════════

  $("markProcessedBtn").addEventListener("click", async () => {
    if (!currentItem) return;
    try {
      const note = $("noteInput").value.trim() || undefined;
      await api("/" + currentItem.id + "/mark-processed", {
        method: "POST",
        body: JSON.stringify({ note }),
      });
      currentItem.status = "processed";
      currentItem.processed_at = new Date().toISOString();
      if (note) currentItem.note = note;
      renderDetail();
      toast("Marked as processed");
    } catch (err) {
      toast("Failed: " + err.message, true);
    }
  });

  $("unprocessBtn").addEventListener("click", async () => {
    if (!currentItem) return;
    try {
      await api("/" + currentItem.id + "/unprocess", {
        method: "POST",
        body: "{}",
      });
      currentItem.status = "new";
      currentItem.processed_at = null;
      renderDetail();
      toast("Reverted to new");
    } catch (err) {
      toast("Failed: " + err.message, true);
    }
  });

  $("saveNoteBtn").addEventListener("click", async () => {
    if (!currentItem) return;
    const note = $("noteInput").value.trim();
    try {
      await api("/" + currentItem.id + "/note", {
        method: "POST",
        body: JSON.stringify({ note }),
      });
      currentItem.note = note;
      renderDetail();
      toast("Note saved");
    } catch (err) {
      toast("Failed: " + err.message, true);
    }
  });

  // ═══════════════════════════════════════════════════════════════════════════
  // HELPERS
  // ═══════════════════════════════════════════════════════════════════════════

  function escHtml(s) {
    const el = document.createElement("span");
    el.textContent = s;
    return el.innerHTML;
  }

  function formatDate(iso) {
    if (!iso) return "—";
    try { return new Date(iso + "Z").toLocaleString(); } catch { return iso; }
  }

  function formatSize(bytes) {
    if (!bytes) return "—";
    if (bytes < 1024) return bytes + " B";
    return (bytes / 1024).toFixed(1) + " KB";
  }

  // ═══════════════════════════════════════════════════════════════════════════
  // OPTIONAL: Load Kyber for post-quantum decryption
  // ═══════════════════════════════════════════════════════════════════════════

  (async function tryLoadKyber() {
    try {
      const mod = await import("https://cdn.jsdelivr.net/npm/kyber-crystals@1.0.7/+esm");
      const k = mod.default ?? mod;
      const kyber = k.kyber ?? k;
      if (kyber && (kyber.decrypt || kyber.decapsulate)) {
        window._kyberDecapsulate = async function(ctB64, skB64) {
          const ct = fromB64(ctB64);
          const sk = fromB64(skB64);
          const r = kyber.decrypt ? await kyber.decrypt(ct, sk) : await kyber.decapsulate(ct, sk);
          const key = (r && (r.key ?? r.sharedSecret)) ? (r.key ?? r.sharedSecret) : r;
          return new Uint8Array(key);
        };
      }
    } catch {
      // Kyber not available in browser - X25519 fallback will be used
    }
  })();

  // ═══════════════════════════════════════════════════════════════════════════
  // INIT
  // ═══════════════════════════════════════════════════════════════════════════

  loadList();
})();
</script>
</body>
</html>
